r"""
GKLO homomorphism for quiver gauge theories and truncated shifted Yangians of simple simply-laced Lie algebras

AUTHORS:

- Artem Kalmykov (2025-10-14): Initial version
"""

# ****************************************************************************
#  Copyright (C) 2025 Artem Kalmykov <artem.o.kalmykov at gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************

from sage.misc.cachefunc import cached_method
from sage.misc.misc_c import prod
from sage.arith.misc import factorial
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.combinat.root_system.root_system import RootSystem
from sage.combinat.subset import Subsets

from difference_operators import DifferenceOperators, MonadTuple

class QuiverGKLO(DifferenceOperators):
    r"""
    The algebra of difference operators realizing the Coulomb branch of a quiver gauge theory via an analog of the GKLO homomorphism
    based on constructions of [BFN2019].

    Let Q=(Q0, Q1) be a quiver with vertices `rank` vertices parameterized as Q0 = {0, 1, ..., `rank`-1} and arrows Q1. 
    Let v = (v_0, ..., v_{`rank`-1}), w = (w_0, ..., w_{`rank`-1}) be a tuple of non-negative integers. Define vector spaces 
    
    .. MATH:: 
        V_i = C^{v_i},\ W_j = C^{w_j},

    and 
    
    .. MATH:: 
        N = \bigoplus_{h\in Q_1} Hom(V_{o(h)}, V_{i(h)})) \oplus \bigoplus_{i in Q0} Hom(W_i, V_i). 
    
    Let 
    
    .. MATH:: 
        GL(V) := \prod_{i \in Q0} GL(V_i).

    To the data (GL(V), N), [BFN2019] assign a non-commutative algebra A_{\hbar}, the equivariant Borel-Moore homology 
    
    .. MATH:: 
        H_*^{GL(V)_{\mathcal{O}} \rtimes \C^*}(R) 
    
    with respect to the convolution product (see loc. cit. for notations). This algebra admits a homomorphism to a certain localization of the algebra of difference operators
    \tilde{A}_{\hbar} generated by p_{i,r} and u_{i,r}^{\pm 1} for i=0,...,`rank`-1 and r=0,...,v_i-1 and with relations 
    
    .. MATH:: 
        [u_{i,r}^{\pm},p_{j,s}] = \pm \delta_{ij} \delta_{rs} \hbar u_{i,r}^{\pm}.

    What this class implements:
    --- The localized algebra of difference operators itself (based on more general ``DifferenceOperator`` class)
    --- A direct generalization of the currents A_i(z), E_i(z), F_i(z), H_i(z) of [Theorem B.15,BFN2019] 
        for an arbitrary quiver, not necessarily of finite Dynkin type (should correspond to the so-called "quiver Yangian" in the sense of [LY2020])
    --- Minuscule monopole operators in the sense of (A.3) and (A.5) of [BFN2019]

    .. TODO::
        - Allow arbitrary R
        - Add additional \C^* equivariant parameters when quiver has loops
        - Add non-simply laced types (to consult with experts in the field)

    INPUT::
    - ``base_ring`` -- base ring for the algebra of difference operators. For all the constructions of [BFN2019], rational field ``QQ`` is sufficient.
    - ``v`` -- vector of dimensions associated to nodes 0,1,...,`rank`-1.
    - ``w`` -- vector of framing dimensions associated to nodes 0,1,...,`rank`-1.
    - ``Q1`` : `dict` or `list` -- arrows of the quiver.
        If `Q1` is of type `dict`, it should be of the form {i : ls} where ``i`` is from 0 to `rank`-1 (corresponds to the node) and ``ls`` is the vertices outgoing from ``i``.
        Otherwise, should be a `list` of arrows of the form `(i[h],o[h])`, where `i[h]` is the start of `h` and `o[h]` is the end of `h`.
        For instance, for D4 Dynkin quiver, a possible choice is Q1 = {0: 1, 1: [2, 3]} or Q1 = [(0,1), (1,2), (1,3)].
        For A2 Dynkin quiver, a possible choice is Q1 = {0: 1} or Q1 = [(0,1)], while Q1 = (0,1) is not allowed
    - ``spectral_vars`` -- (default: ``'t```) list of names of spectral variables. Used to constuct the current generators H_i(t), E_i(t), F_i(t), A_i(t). At least one is necessary
    - ``asymptotic`` : `bool` -- (default: `False`) if `True`, quantization parameter is ``hbar_multiple``*`h`, where `h` is a formal parameter, otherwise quantization parameter is ``hbar_multiple``
    - ``hbar_multiple`` -- (default: `1`) sets multiple of (formal or non-formal) quantization parameter, see description of ``asymptotic``.
    - ``var_prefix`` : `str` -- (default: ```p```) name of function variables
    - ``diff_prefix`` : `str` -- (default: ```u```) name of difference operators

    EXAMPLES::

        sage: G = QuiverGKLO(base_ring=QQ, v=(1, 1), w=(1, 0), Q1={0: [1]})
        sage: p = G.functional_variables(); p
        Finite family {(0, 0): p_0_0, (1, 0): p_1_0}
        sage: u = G.difference_operators(); u
        Finite family {(0, 0): u_0_0, (1, 0): u_1_0}
        sage: p[1,0]*u[1,0]**(-1)
        p_1_0*u_1_0^-1
        sage: u[1,0]**(-1)*p[1,0]
        (p_1_0-1)*u_1_0^-1
        sage: G.E(1)
        -(1/(t-p_1_0))*u_1_0^-1
        sage: G.A(0)
        (t - p_0_0)/t
        sage: G1 = QuiverGKLO(v=(1,), w=(1,), Q1=())
        sage: G1.p()[0,0]*G.u()[1,0]
        p_0_0*u[1,0]

    REFERENCES:
    
    - [BFN2019]_
    - [LY2020]_ 
    """

    @staticmethod
    def __classcall_private__(cls, base_ring, v, w, Q1, spectral_vars='t', asymptotic=False, hbar_multiple=1, var_prefix='p', diff_prefix='u'):
        r"""
        Return the correct parent based upon input.
        Preprocesses ``v``, ``w``, ``Q``, ``spectral_vars`` to their ``tuple`` realizations to ensure a unique and hashable representation.

        EXAMPLES::

            sage: G = QuiverGKLO(base_ring=QQ, v=(1,1), w=(1,0), Q1={0:[1]})
            sage: G1 = QuiverGKLO(base_ring=QQ, v=[1,1], w=(1,0), Q1=[(0,1)])
            sage: G1 is G
            True
            sage: G2 = QuiverGKLO(base_ring=QQ, v=[1,1], w=(1,0), Q1=[(0,1)], asymptotic=True)
            sage: G2 is G
            False
        """
        def _quiver_preprocessing(Q1):
            if isinstance(Q1, dict):
                ls = [(i,o) for i in Q1.keys() for o in MonadTuple(Q1[i])]
                return tuple(ls)
            if isinstance(Q1, list):
                return tuple(Q1)
            raise TypeError("Quiver arrows ``Q1`` should be of type either  `dict` or `list`")

        v, w = MonadTuple(v), MonadTuple(w)
        Q1 = _quiver_preprocessing(Q1)
        spectral_vars = MonadTuple(spectral_vars)
        return super().__classcall__(cls, base_ring, v, w, Q1, spectral_vars, asymptotic, hbar_multiple, var_prefix, diff_prefix)
    
        
    def __init__(self, base_ring, v, w, Q1, spectral_vars, asymptotic, hbar_multiple, var_prefix, diff_prefix):
        r"""
        Initialize ``self``.
        """
        self._type_check_(v, w, Q1, spectral_vars)

        self.rank = len(v)
        self._v = v
        self._w = w
        self._arrows = Q1
        self._spectral_vars_str = spectral_vars

        if asymptotic:
            base = PolynomialRing(base_ring, 'h').fraction_field()
            self._hbar = hbar_multiple*base.gen()
        if not asymptotic:
            base = base_ring
            self._hbar = base_ring(hbar_multiple)

        self._R = tuple([tuple([-self._hbar/2]*dim) for dim in self._w])

        self._var_prefix = var_prefix
        self._diff_prefix = diff_prefix

        I = [(i,j) for i in range(self.rank) for j in range(self._v[i])]
        super().__init__(base, I, shift=self._hbar, variable_prefix=self._var_prefix, difference_operator_prefix=self._diff_prefix, additional_variables=self._spectral_vars_str)

    def monopole_operator(self, i, n, dual=False):
        """
        Return the (i,n) monopole operator (A.4) if ``dual``==`False` or (A.5) if ``dual``==`True` [BFN2019].

        EXAMPLES::

            sage: G = QuiverGKLO(base_ring=QQ, v=2, w=0, Q1=[]) #Corresponds to the quantum Toda
            sage: G.monopole_operator(0,1)
            (1/(p_0_0-p_0_1))*u_0_0 + (1/(-p_0_0+p_0_1))*u_0_1
            sage: G.monopole_operator(0,2,dual=True)
            u_0_0^-1*u_0_1^-1

            sage: G = QuiverGKLO(base_ring=QQ, v=(1,2,2,1), w=(0,1,0,0), Q1=[(0,1),(1,2),(2,3)])
            sage: x = G.monopole_operator(1,1); x
            ((p_0_0-p_1_0-1/2)/(p_1_0-p_1_1))*u_1_0 + ((p_0_0-p_1_1-1/2)/(-p_1_0+p_1_1))*u_1_1
            sage: y = G.monopole_operator(1,2); y
            sage: y
            (p_0_0^2-p_0_0*p_1_0-p_0_0*p_1_1+p_1_0*p_1_1-p_0_0+1/2*p_1_0+1/2*p_1_1+1/4)*u_1_0*u_1_1
            sage: x*y - y*x
            0
        """
        I = Subsets(range(self._v[i]), k=n)
        element = self.zero()
        for subset in I:
            if not dual:
                arrows = self._from_tuple_to_dict(inverse=True)
                numerator = self.base_ring().one()
                if arrows.get(i) != None:
                    for j in arrows[i]:
                        for s in range(self._v[j]):
                            if j==i and s in subset:
                                continue
                            else:
                                for r in subset:
                                    numerator *= (-self.functional_variables()[i,r] + self.functional_variables()[j,s] - self.hbar()/2)
                denominator = prod([self.functional_variables()[i,r] - self.functional_variables()[i,s] for r in subset for s in range(self._v[i]) if not s in subset])
                element += numerator/denominator*prod([self.difference_operators()[i,r] for r in subset])
            if dual:
                arrows = self._from_tuple_to_dict(inverse=False)
                numerator = self.base_ring().one()
                if arrows.get(i) != None:
                    for j in arrows[i]:
                        for s in range(self._v[j]):
                            if j==i and s in subset:
                                continue
                            else:
                                for r in subset:
                                    numerator *= (self.functional_variables()[i,r] - self.functional_variables()[j,s] - self.hbar()/2)
                denominator = prod([-self.functional_variables()[i,r] + self.functional_variables()[i,s] for r in subset for s in range(self._v[i]) if not s in subset])
                element += prod([self.functional_variables()[i,r] - z - self.hbar()/2 for z in self._R[i] for r in subset])*numerator/denominator*prod([self.difference_operators()[i,r]**(-1) for r in subset])
        return element

    def __repr__(self):
        r"""
        Return a string representation of ``self''.

        EXAMPLES::

            sage: G = QuiverGKLO(base_ring=QQ, v=2, w=0, Q1=[])
            sage: G
            Algebra of difference operators over Rational Field with quantization parameter 1 and spectral parameters ('t',) realizing the Coulomb branch of the quiver gauge theory with vertices {0}, and arrows (), dimension vector (2,), framings (0,)

            sage: G1 = QuiverGKLO(base_ring=QQ, v=(1,2,2,1), w=(0,1,0,0), Q1=[(0,1),(1,2),(2,3)], asymptotic=True, hbar_multiple=-2, var_prefix='w', diff_prefix='D')
            sage: G1
            Algebra of difference operators over Fraction Field of Univariate Polynomial Ring in h over Rational Field with quantization parameter -2*h and spectral parameters ('t',) realizing the Coulomb branch of the quiver gauge theory with vertices {0, 1, 2, 3}, and arrows ((0, 1), (1, 2), (2, 3)), dimension vector (1, 2, 2, 1), framings (0, 1, 0, 0)
        """
        return "Algebra of difference operators over {} with quantization parameter {} and spectral parameters {} realizing the Coulomb branch of the quiver gauge theory with vertices {} and arrows {}, dimension vector {}, framings {}".format(self.base_ring().base_ring(), self._hbar,self._spectral_vars_str,set(range(self.rank)),self._arrows,self._v,self._w)

    def hbar(self):
        r"""
        Return quantization parameter ``hbar``.

        EXAMPLES::

            sage: G = QuiverGKLO(base_ring=QQ, v=2, w=0, Q1=[])
            sage: G.hbar()
            1

            sage: G1 = QuiverGKLO(base_ring=QQ, v=(1,2,2,1), w=(0,1,0,0), Q1=[(0,1),(1,2),(2,3)], asymptotic=True, hbar_multiple=-2, var_prefix='w', diff_prefix='D')
            sage: G1.hbar()
            -2*h
        """
        return self._hbar

    def v(self):
        r"""
        Return the dimension vector v of ``self``.

        EXAMPLES:

            sage: G = QuiverGKLO(base_ring=QQ, v=2, w=0, Q1=[])
            sage: G.v()
            (2,)

            sage: G1 = QuiverGKLO(base_ring=QQ, v=(1,2,2,1), w=(0,1,0,0), Q1=[(0,1),(1,2),(2,3)], asymptotic=True, hbar_multiple=-2, var_prefix='w', diff_prefix='D')
            sage: G1.v()
            (1, 2, 2, 1)
        """

        return self._v
    
    def w(self):
        r"""
        Return the vector of framing dimensions of ``self``.

        EXAMPLES::

            sage: G = QuiverGKLO(base_ring=QQ, v=2, w=0, Q1=[])
            sage: G.w()
            (0,)

            sage: G1 = QuiverGKLO(base_ring=QQ, v=(1,2,2,1), w=(0,1,0,0), Q1=[(0,1),(1,2),(2,3)], asymptotic=True, hbar_multiple=-2, var_prefix='w', diff_prefix='D')
            sage: G1.w()
            (0, 1, 0, 0)
        """
        return self._w
    
    def R(self):
        r"""
        Return the flavor symmetry parameters R.
        OUTPUT:: `tuple` of length=`rank` whose i-th term is a `tuple` of length self._w[i] 

        EXAMPLES::

            sage: G2 = QuiverGKLO(base_ring=QQ, v=(1,2,1), w=(1,0,0), Q1={0: [1], 1: [2]},asymptotic=True)
            sage: G2.R()
            ((-1/2*h,), (), ())

        .. NOTE:: only standard choice of all parameters equal to -\hbar/2 is implemented.
        """
        return self._R
    
    def arrows(self):
        r"""
        Return the arrows of the underlying quiver.
        OUTPUT:: `tuple' of arrows (h_1,...,h_k) where each arrow `h' is represented by a `tuple' (i(h),o(h)) [i(h)=input node,o(h)=output node].

        EXAMPLES::

            sage: G2 = QuiverGKLO(base_ring=QQ, v=(1,2,1), w=(1,0,0), Q1={0: [1], 1: [2]},asymptotic=True)
            sage: G2.arrows()
            ((0, 1), (1, 2))
            sage: G1 = QuiverGKLO(base_ring=QQ, v=(1,2,2,1), w=(0,1,0,0), Q1=[(0,1),(1,2),(2,3)], asymptotic=True, hbar_multiple=-2, var_prefix='w', diff_prefix='D')
            sage: G1.arrows()
            ((0, 1), (1, 2), (2, 3))
        """
        return self._arrows
    
    @cached_method
    def spectral_variables(self):
        r"""
        Return a list of all spectral variables.

        EXAMPLES::

            sage: G = QuiverGKLO(base_ring=QQ, v=(1,1), w=(1,0), Q1={0: [1]}, spectral_vars=('t','s','z'))
            sage: G.spectral_variables()
            (t, s, z)
            sage: t, s, z = G.spectral_variables()
            sage: t**2/z
            t^2/z
        """
        return self.additional_variables()
    
    @cached_method
    def _H_spectral_(self, i):
        r"""
        Auxiliary function: return (H_i(z),d[i]), see notations for the main function self.H(i).

        Output depends on the first spectral variable.

        EXAMPLES::

            sage: G = QuiverGKLO(base_ring=QQ, v=(1,1), w=(1,0), Q1={0: [1]}, spectral_vars=('t','s','z'))
            sage: G._H_spectral_(1)
            ((t - p_0_0 - 1/2)/(t^2 - 2*t*p_1_0 + p_1_0^2 - t + p_1_0), -1)
            sage: G._H_spectral_(1)[0] == G.H(1)
            True
            sage: G._H_spectral_(0)
            ((t^2 - t*p_1_0 - 1/2*t)/(t^2 - 2*t*p_0_0 + p_0_0^2 - t + p_0_0), 0)
        """
        arrows = self._from_tuple_to_dict()
        for input,output in self._from_tuple_to_dict(inverse=True).items():
            if arrows.get(input) != None:
                arrows[input] += output
            else:
                arrows[input] = output
        if arrows.get(i) == None:
            arrows[i] = ()
        degree = sum([self._v[r] for r in arrows[i]]) - 2*self._v[i] + self._w[i]
        t = self.spectral_variables()[0]
        kwargs = {self._spectral_vars_str[0] : t - self._hbar/2}
        numerator = prod([(t-self._hbar/2)**self._v[r]*self.A(r)(**kwargs) for r in arrows[i]])
        kwargs = {self._spectral_vars_str[0] : t - self._hbar}
        denominator = t**self._v[i]*(t - self._hbar)**self._v[i]*self.A(i)*self.A(i)(**kwargs)
        return self.Z(i,t)*numerator/denominator,degree
    
    def H(self, i, k=None):
        r"""
        Return the (direct analog of) H-generator of (B.14) and Theorem B.15 [BFN2019]. 

        Let 
        
        .. MATH::
            d[i] = self.w[i] + \sum_{j~i} self.v[j] - 2*self.v[i], 
            
        where `j~i' are all nodes ``j'' connected to ``i'' (excluding ``i'') in Q and its inversion \bar{Q}.
        Let 
        
        .. MATH::
            H_i(z) = H_i^{(d[i])}*z^{-d[i]} + H_i^{(d[i]+1)}*z^{-d[i]-1} + ... = \sum_{k>=d[i]} H_i^{(k)}*z^{-k}.

        .. NOTE:: uses auxiliary function self._H_spectral_(i) computing (B.14). If ``k``==`None`, self.H(i) returns (B.14). Otherwise, computes (``k``+d[i])-term in the Taylor expansion of z^{d[i]}*H_i(z) via derivatives.

        INPUT::
            - ``i`` -- index from 0 to (``rank``-1)
            - ``k`` -- (optional) the ``k``-th mode

        OUTPUT:: 
            - if ``k`` is ``None``: H_i(t), where ``t'' is the first spectral variable of the class (t==self.spectral_variables()[0])
            - if ``k`` is not ``None'': H_i^{(k)}. In particular, if ``k`` < d[i], returns `0`.

        EXAMPLES::

            sage: G = QuiverGKLO(base_ring=QQ, v=(1,1), w=(1,0), Q1={0: [1]}, spectral_vars=('t','s','z'))
            sage: G.H(1)
            (t - p_0_0 - 1/2)/(t^2 - 2*t*p_1_0 + p_1_0^2 - t + p_1_0)
            sage: G.H(1,1)
            1
            sage: G.H(1,2)
            -p_0_0 + 2*p_1_0 + 1/2

            sage: G = QuiverGKLO(base_ring=QQ, v=1, w=0, Q1=[], spectral_vars='t', asymptotic=True)
            sage: t, hbar = G.spectral_variables()[0], G.hbar()
            sage: G.A(0)
            (t - p_0_0)/t
            sage: G.H(0)
            1/(t^2 - 2*t*p_0_0 + p_0_0^2 + (-h)*t + h*p_0_0)
            sage: G.H(0) == 1/(G.A(0)*G.A(0)(t=t-hbar))*1/(t*(t-hbar))
            True
        """
        if k == None:
            return self._H_spectral_(i)[0]
        else:
            t = self.spectral_variables()[0]
            H_spectral, degree = self._H_spectral_(i)
            H_spectral = H_spectral*t**(-degree)
            k = k + degree
            if k < 0:
                return self.zero()
            _H_derivative = H_spectral(**{self._spectral_vars_str[0] : 1/t}).derivative(t, k)/factorial(k)
            return _H_derivative(**{self._spectral_vars_str[0]: 0})

    
    def A(self, i, k=None):
        r"""
        Return the (direct analog of) A-generator of Theorem B.15 of [BFN2019].

        Let 
        
        .. MATH:: 
            A_i(z) = \sum_{k>=0} A_i^{(k)} z^{-k}

        INPUT:: 
            - ``i`` -- index of the node
            - ``k`` -- (optional) ``k``-th mode of A(z) current.

        OUTPUT:: 
            - if ``k`` == None: current A_i(t), where ``t`` is the first spectral variable of the class (t==self.spectral_variables()[0])
            - otherwise: A_i^{(k)} in the notations above. In particular, if ``k`` < 0, returns `0`.

        EXAMPLES::

            sage: G = QuiverGKLO(base_ring=QQ, v=(1,2,2,1), w=(0,1,0,0), Q1={0: [1], 1: [2], 2: [3]}, spectral_vars='t')
            sage: G.A(0)
            (t - p_0_0)/t
            sage: G.A(0,1)
            -p_0_0
            sage: G.A(0,0)
            1
            sage: G.A(1)
            (t^2 - t*p_1_0 - t*p_1_1 + p_1_0*p_1_1)/t^2
        """
        t = self.spectral_variables()[0]
        if k == None:
            return t**(-self._v[i])*self.W(i,t)
        else:
            A_spectral = self.A(i)(**{self._spectral_vars_str[0]: 1/t})
            if k<0:
                return 0
            else:
                return A_spectral.derivative(t,k)(**{self._spectral_vars_str[0]: 0})/factorial(k)

    def E(self, i, k=None):
        r"""
        Return the (direct analog of) E-generator of Theorem B.15 [BFN2019].
        Let 
        
        .. MATH:: 
            E_i(z) = \sum_{k>0} E_i^{(k)} z^{-k}.

        INPUT::
            - ``i`` -- index of the node
            - ``k`` -- (optional) k-th mode of the E_i(z)

        OUTPUT::
            - if ``k`` == `None`: current E_i(t), where ``t`` is the first spectral variable of the class (t==self.spectral_variables()[0])
            - otherwise: E_i^{(k)} in the notations above. In particular, if ``k`` <= 0, returns `0`.

        EXAMPLES::
            sage: G = QuiverGKLO(base_ring=QQ, v=(1,1), w=(1,0), Q1={0: [1]}, spectral_vars='t')
            sage: G.E(1)
            -(1/(t-p_1_0))*u_1_0^-1
            sage: G.E(1,1)
            -u_1_0^-1
            sage: G.E(1,2)
            -p_1_0*u_1_0^-1
            sage: i = 0; j = 1; p = 3; q = 2
            sage: comm(G.E(i,p+1), G.E(j,q)) - comm(G.E(i,p), G.E(j,q+1)) == -G.hbar()/2*(G.E(i,p)*G.E(j,q) + G.E(j,q)*G.E(i,p)) #One of the relations in Definition B.15 [BFN2019]
            True

            sage: G2 = QuiverGKLO(base_ring=QQ, v=(2,2,1,1), w=(1,0,0,0), Q1={0: [1], 1: [2, 3]}, asymptotic=True) 
            sage: i = 0; j = 1; p = 3; q = 2
            sage: comm(G2.E(i,p+1), G2.E(j,q)) - comm(G2.E(i,p), G2.E(j,q+1)) == -G2.hbar()/2*(G2.E(i,p)*G2.E(j,q) + G2.E(j,q)*G2.E(i,p))
            True
            sage: i = 0; j = 2; p = 3; q = 2
            sage: comm(G2.E(i,p+1), G2.E(j,q)) - comm(G2.E(i,p), G2.E(j,q+1)) == 0
            True
        """
        arrows = self._from_tuple_to_dict()
        p = self.functional_variables()
        def arrows_term(r):
            if arrows.get(i) == None:
                return self.one()
            return prod([self.W(j,p[i,r] - self._hbar/2) for j in arrows[i]])
        terms = []
        for r in range(self._v[i]):
            terms.append(-self.Z(i,p[i,r])*arrows_term(r)/self.Wr(i,r,p[i,r])*self.gen((i,r))**(-1))
        if k == None:
            t = self.spectral_variables()[0]
            S = 0
            for r,term in enumerate(terms):
                S += 1/(t - p[i,r])*term
            return S
        else:
            if k <= 0:
                return 0
            S = 0
            for r,t in enumerate(terms):
                S += p[i,r]**(k-1)*t
            return S

    def F(self, i, k=None):
        r"""
        Return the (direct analog of) F-generator of Theorem B.15 [BFN2019].
        Let 
        
        .. MATH:: 
            F_i(z) = \sum_{k>0} F_i^{(k)} z^{-k}.

        INPUT::
            - ``i`` -- index of the node
            - ``k`` -- (optional) k-th mode of the E_i(z)

        OUTPUT::
            - if ``k`` == `None`: current F_i(t), where ``t`` is the first spectral variable of the class (t==self.spectral_variables()[0])
            - otherwise: F_i^{(k)} in the notations above. In particular, if ``k`` <= 0, returns `0`.

        EXAMPLES::

            sage: G = QuiverGKLO(base_ring=QQ, v=(1,1), w=(1,0), Q1={0: [1]}, spectral_vars='t')
            sage: G.F(1)
            -((p_0_0-p_1_0-1/2)/(t-p_1_0-1))*u_1_0
            sage: G.F(1,1)
            -(p_0_0-p_1_0-1/2)*u_1_0
            sage: G.F(1,2)
            -(p_0_0*p_1_0-p_1_0^2+p_0_0-3/2*p_1_0-1/2)*u_1_0
            sage: i = 0; j = 1; p = 3; q = 2
            sage: comm(G.F(i,p+1), G.F(j,q)) - comm(G.F(i,p), G.F(j,q+1)) == G.hbar()/2*(G.F(i,p)*G.F(j,q) + G.F(j,q)*G.F(i,p)) #One of the relations in Definition B.15 in [BFN2019]
            True

            sage: G2 = QuiverGKLO(base_ring=QQ, v=(2,2,1,1), w=(1,0,0,0), Q1={0: [1], 1: [2, 3]}, asymptotic=True)
            sage: i = 0; j = 1; p = 3; q = 2
            sage: comm(G2.F(i,p+1), G2.F(j,q)) - comm(G2.F(i,p), G2.F(j,q+1)) == G2.hbar()/2*(G2.F(i,p)*G2.F(j,q) + G2.F(j,q)*G2.F(i,p))
            True
            sage: i = 0; j = 2; p = 3; q = 2
            sage: comm(G2.F(i,p+1), G2.F(j,q)) - comm(G2.F(i,p), G2.F(j,q+1)) == 0
            True
        """
        arrows = self._from_tuple_to_dict(inverse=True)
        p = self.functional_variables()
        def arrows_term(r):
            if arrows.get(i) == None:
                return self.one()
            return prod([self.W(j,p[i,r] + self._hbar/2) for j in arrows[i]])
        terms = []
        for r in range(self._v[i]):
            terms.append(arrows_term(r)/self.Wr(i,r,p[i,r])*self.gen((i,r)))
        if k==None:
            t = self.spectral_variables()[0]
            S = 0
            for r,term in enumerate(terms):
                S += 1/(t - p[i,r] - self._hbar)*term
            return S
        else:
            if k<=0:
                return 0
            S = 0
            for r,t in enumerate(terms):
                S += (p[i,r] + self._hbar)**(k-1)*t
            return S

    def Z(self, i, var):
        r"""
        Return Z_i(var) from B(ii) of [BFN2019].

        EXAMPLES::

            sage: G = QuiverGKLO(base_ring=QQ, v=(1,1), w=(1,0), Q1={0: [1]}, spectral_vars='t')
            sage: t = G.spectral_variables()[0]
            sage: G.Z(0,t)
            t
            sage: G.Z(1,t)
            1
        """
        return prod([var - r - self._hbar/2 for r in self._R[i]])
    
    def W(self, i, var):
        r"""
        Return W_i(var) from B(ii) of [BFN2019].

        EXAMPLES::

            sage: G2 = QuiverGKLO(base_ring=QQ, v=(2,2,1,1), w=(1,0,0,0), Q1={0: [1], 1: [2, 3]}, asymptotic=True)
            sage: t = G2.spectral_variables()[0]
            sage: G2.W(0, t)
            t^2 - t*p_0_0 - t*p_0_1 + p_0_0*p_0_1
            sage: G2.W(2, t)
            t - p_2_0
            sage: G2.W(2, p[2,0])
            0
        """
        p = self.functional_variables()
        return prod([var - p[i,s] for s in range(self._v[i])])
    
    def Wr(self, i, r, var):
        r"""
        Return W_{i,r}(var) from B(ii) of [BFN2019].

        EXAMPLES::

            sage: G2 = QuiverGKLO(base_ring=QQ, v=(2,2,1,1), w=(1,0,0,0), Q1={0: [1], 1: [2, 3]}, asymptotic=True)
            sage: t = G2.spectral_variables()[0]
            sage: G2.Wr(0, 1, t)
            t - p_0_0
            sage: G2.Wr(0, 0, t)
            t - p_0_1
        """
        p = self.functional_variables()
        return prod([var - p[i,s] for s in range(self._v[i]) if s != r])

    def _coerce_map_from_(self, R):
        r"""
        Return ``True`` or the coercion if there exists a coerce map from ``R``.

        Such coercion exists if: 
            - ``R`` has the same base ring as ``self``
            - ``R'' corresponds to a subquiver of ``self'' (with vertices of ``R`` and ``self`` having the same numbering)
            - for each node, dimensions of ``R`` are smaller than those of ``self`` (including framings)
            - quantization parameters of ``R'' and ``self`` are equal
            - spectral variables of ``R`` form a subset of spectral variables of ``self``

        .. NOTE:: so far, it works well, but for future, I need to change ``module_morphism`` function 
            (it uses incorrect category, see the remark in `difference_operators.py` for more details).

        EXAMPLES::

            sage: G = QuiverGKLO(base_ring=QQ, v=(1,1), w=(1,0), Q1={0: [1]}, spectral_vars='t')
            sage: G1 = QuiverGKLO(base_ring=QQ, v=(1,2,1), w=(1,0,0), Q1={0:[1], 1:[2]})
            sage: G1.has_coerce_map_from(G)
            True
            sage: phi = G1._coerce_map_from_(G)
            sage: u = G.difference_operators(); u
            Finite family {(0, 0): u_0_0, (1, 0): u_1_0}
            sage: phi(u[0,0])
            u_0_0
            sage: phi(u[0,0]).parent() == G1
            True
            sage: p = G.functional_variables()
            sage: x = p[1,0]*phi(u[0,0]); x
            p_1_0*u_0_0
            sage: x.parent() == G1
            True
        """
        if isinstance(R, QuiverGKLO):
            is_equal_base_ring = (R.base_ring().base_ring() == self.base_ring().base_ring())
            is_smaller_dim_v = (R._v <= self._v)
            is_smaller_dim_w = (R._w <= self._w)
            is_subset_arrows = (set(R._arrows) <= set(self._arrows))
            is_subset_spectral_variables = (set(R._spectral_variables_str) <= set(self._spectral_variables_str))
            is_equal_quantization_parameter = (R._hbar == self._hbar)
            # The following is simply the boolean product of all the conditions above
            is_coercible = is_equal_base_ring & is_smaller_dim_v & is_smaller_dim_w & is_subset_arrows & is_subset_spectral_variables & is_equal_quantization_parameter
            if is_coercible:
                indices = self.indices()
                on_gens = lambda m: self.monomial(prod([indices.gen(a)**exp for a,exp in m._sorted_items()]))
                return R.module_morphism(on_gens, codomain=self)
        return super()._coerce_map_from_(R)

    
    def _from_tuple_to_dict(self, inverse=False):
        r"""
        Auxiliary function: return a `dict' representation of quiver arrows from `tuple` representation.

        OUTPUT:: 
            - if ``inverse`` == `False`: `dict` whose keys are vertices of the quiver and the corresponding value is `list` of outgoing vertices.
            - if ``inverse`` == `True`: same but for the opposite quiver.

        EXAMPLES::

            sage: G1 = QuiverGKLO(base_ring=QQ, v=(1,2,1), w=(1,0,0), Q1={0:[1], 1:[2]})
            sage: G1._from_tuple_to_dict()
            {0: [1], 1: [2]}
            sage: G2 = QuiverGKLO(base_ring=QQ, v=(1,2,1), w=(1,0,0), Q1=[(0,1),(1,2)])
            sage: G2._from_tuple_to_dict()
            {0: [1], 1: [2]}
            sage: G2._from_tuple_to_dict(inverse=True)
            {1: [0], 2: [1]}
        """
        d_list = {}
        i = int(inverse)
        o = 1 - int(inverse)
        for q in self._arrows:
            if d_list.get(q[i]) != None:
                d_list[q[i]].append(q[1])
            else:
                d_list[q[i]] = [q[o]]
        return d_list
    

    def _type_check_(self, v, w, Q1, spectral_vars):
        """
        Auxiliary function: return ``None`` if all parameters are correct, otherwise raise exception. 

        EXAMPLES::

            sage: G = QuiverGKLO(base_ring=QQ, v=(1,1), w=(1,0),Q1={0:[1]})
            sage: G = QuiverGKLO(base_ring=QQ, v=(-1,1), w=(1,0), Q1={0: [1]})
            TypeError: Dimension vector 'v' should contain only non-negative values

            sage: G = QuiverGKLO(base_ring=QQ, v=(1,1), w=(1,0), Q1={0: [2]})
            TypeError: Vertices of the quiver should be in range from 0 to 1
        """
        def _vertices_set(Q1):
            S = set(a[0] for a in Q1)
            S.update(set(a[1] for a in Q1))
            return S
        
        """
        Check that dimension vectors 'v' and 'w' have the same length.
        """
        if len(v) != len(w):
            raise TypeError("Dimensions of 'v' and 'w' do not match")
        rank = len(v)

        """
        Check that dimension vector 'v' has only non-negative entries.
        """
        for dim in v:
            if dim < 0:
                raise TypeError("Dimension vector 'v' should contain only non-negative values")
            
        """
        Check that dimension vector 'w' has only non-negative entries.
        """
        for dim in w:
            if dim < 0:
                raise TypeError("Dimension vector 'w' should contain only non-negative values")
            
        """
        Check that the vertices of the arrows are vertices of the dimension vectors.
        """
        if not _vertices_set(Q1) <= set(range(rank)):
            raise TypeError("Vertices of the quiver should be in range from 0 to {}".format(rank-1))
        
        """
        For correct functioning of certain functions, at least one spectral parameter is needed.
        """
        if not spectral_vars:
            raise TypeError("At least one spectral parameter is required")

    
    class Element(DifferenceOperators.Element):
        def derivative(self,var,k=1):
            r"""
            Return derivative of ``self`` with respect to spectral variable ``var``.
            Mainly used in constructing `A` and `H` generators of the quiver Yangian.

            EXAMPLES::

                sage: G = QuiverGKLO(base_ring=QQ, v=(1,1), w=(1,0), Q1={0: [1]})
                sage: t = G.spectral_variables()[0]
                sage: u = G.difference_operators(); p = G.functional_variables()
                sage: element = (t+1)*u[0,0]; element
                (t+1)*u_0_0
                sage: element.derivative(t,1)
                u_0_0
                sage: element.derivative(t,2)
                0
            """
            parent = self.parent()
            if not (var in parent.spectral_variables()):
                raise TypeError("Derivative of a difference operator is defined only for spectral variables")
            new_element_dict = {}
            for monom,coeff in self.monomial_coefficients().items():
                new_element_dict[monom] = coeff.derivative(var,k)
            return parent._from_dict(new_element_dict)


class GKLO(QuiverGKLO):
    r"""
    Algebra of difference operators realizing the (generalization of) GKLO representation for truncated shifted Yangian \Y(\g)^{\lmbd}_{\mu}.
    Child class of `QuiverGKLO'.

    Let \g be a simple simply-laced Lie algebra of finite type and \lmbd,\mu two coweights such that:
        - \lmbd is dominant; in particular, \lmbd = \sum_i l_i \omega_i, where \omega_i are fundamental coweights;
        - \lmbd - \mu = \sum_i a_i \alpha_i, where \alpha_i are simple coroots and a_i >= 0.

    To this data, one can the quiver gauge theory with Q being the Dynkin quiver (with arbitrary orientation), dimension vector (a_0,...,a_{rank(\g)-1}),
    and framing vector (l_0,...,l_{rank(\g)-1}), and the corresponding GKLO representation. The truncated shifted Yangian is the subalgebra inside difference operators 
    generated by H_i^{(k)}, E_i^{(k)}, F_i^{(k)} for all possible i,k, see Theorem B.15 in [BFN2019] and the corresponding functions in `QuiverGKLO`.

    INPUT::
        - ``root_system`` -- a finite simply-laced root_system. Possible inputs:
            - ``[s,rank]`` : list where ``s`` is in {'A','D','E'} and ``n`` is an appropriate rank
            - ``S`` : str where S[0] in {'A','D','E'} and S[1] is the string of rank
            - an object of from `sage.combinat.root_system.root_system.RootSystem`
        - ``lmbd`` -- a dominant coweight. Possible inputs:
            - An element of `L=R.coambient_lattice() where R = RootSystem(root_system)` is the SageMath implementation of the root system
            - A `tuple` or `list` representation of elements of ``L`` (see examples below)
        - ``mu`` -- a coweight such that lmbd > mu. Possible inputs: same as `lmbd'.
        For the rest, see the corresponding documentation of `QuiverGKLO':
            - ``base_ring``
            - ``spectral_vars``
            - ``asymptotic``
            - ``hbar_multiple``
            - ``var_prefix``
            - ``diff_prefix``

    .. ALGORITHM:: numeration of nodes of the Dynkin diagram is taken from SageMath `RootSystem', from 0 to rank(\g)-1. Orientation of the Dynkin quiver 
    is chosen in the following way: i -> j if i < j and C_{ij} == -1, where C_{ij} is the corresponding entry in the Cartan matrix. 

    EXAMPLES::

        sage: R = RootSystem("A3"); L = R.coambient_space(); W = L.weyl_group()
        sage: lmbd = L.fundamental_weight(1); mu = W.w0.action(lmbd)
        sage: lmbd
        (1, 0, 0, 0)
        sage: mu
        (0, 0, 0, 1)
        sage: G = GKLO(QQ, R, lmbd, mu)
        sage: G.v() # Dimension vector of the corresponding quiver gauge theory
        (1, 1, 1)
        sage: G.w() # Framing dimension vector of the corresponding quiver gauge theory
        (1, 0, 0)
        sage: G.arrows()
        ((0, 1), (1, 2))
        sage: u = G.difference_operators(); p = G.functional_variables()
        sage: u
        Finite family {(0, 0): u_0_0, (1, 0): u_1_0, (2, 0): u_2_0}
        sage: p
        Finite family {(0, 0): p_0_0, (1, 0): p_1_0, (2, 0): p_2_0}
        sage: u[1,0]**(-1)*p[1,0]
        (p_1_0-1)*u_1_0^-1

        sage: Lcheck = R.ambient_space(); alpha = Lcheck.simple_roots(); alpha # Introducing simple roots of `root_system` in its `ambient_space` realization
        Finite family {1: (1, -1, 0, 0), 2: (0, 1, -1, 0), 3: (0, 0, 1, -1)}
        sage: beta = alpha[1] + alpha[2]; beta
        (1, 0, -1, 0)
        sage: G.positive_root_generator(beta, 1, verbosity=True) # Compute a positive root generators associated to \beta
        Explicit form: [E_1^(1),E_0^(1)]
        (p_0_0*p_1_0-p_0_0*p_2_0-1/2*p_0_0)*u_0_0^-1*u_1_0^-1
        sage: comm(G.E(1,1), G.E(0,1)) == G.positive_root_generator(beta, 1)
        True

        sage: G1 = GKLO(QQ, root_system="A3", lmbd=(1,0,0,0), mu=(0,0,0,1))
        sage: G1 is G
        True

        sage: R = RootSystem("D4"); L = R.coambient_space(); W = L.weyl_group()
        sage: lmbd = L.fundamental_weight(1); mu = W.w0.action(lmbd)
        sage: G2 = GKLO(QQ, R, lmbd, mu)
        sage: G2.v()
        (2, 2, 1, 1)
        sage: G2.w()
        (1, 0, 0, 0)
        sage: G2.arrows()
        ((0, 1), (1, 2), (1, 3))
    """
    @staticmethod
    def __classcall_private__(cls, base_ring, root_system, lmbd, mu, spectral_vars='t', asymptotic=False, hbar_multiple=1, var_prefix='p', diff_prefix='u'):
        r"""
        Return the correct parent based upon input.
        Preprocesses ``root_system``, ``lmbd``, and ``mu`` to ensure a unique representation.

        EXAMPLES::

            sage: R = RootSystem("D4"); L = R.coambient_space(); W = L.weyl_group()
            sage: lmbd = L.fundamental_weight(1); mu = W.w0.action(lmbd)
            sage: lmbd
            (1, 0, 0, 0)
            sage: mu
            (-1, 0, 0, 0)
            sage: G = GKLO(QQ, R, lmbd, mu)
            sage: G1 = GKLO(QQ, "D4", lmbd=(1,0,0,0), mu=(-1,0,0,0)) # Observe that ``lmbd`` and ``mu`` are simply tuples of integers
            sage: G1 is G
            True
        """
        root_system = RootSystem(root_system)
        coambient_space = RootSystem(root_system).coambient_space()
        lmbd, mu = coambient_space(lmbd), coambient_space(mu)

        return super().__classcall__(cls, base_ring, root_system, lmbd, mu, spectral_vars, asymptotic, hbar_multiple, var_prefix, diff_prefix)

    def __init__(self, base_ring, root_system, lmbd, mu, spectral_vars, asymptotic, hbar_multiple, var_prefix, diff_prefix):
        r"""
        Initialize ``self``.
        """
        self.root_system = root_system
        ambient_space = root_system.ambient_space()

        if not self.root_system.is_finite() and not (self.root_system.cartan_type()[0] in {'A', 'D', 'E'}):
            raise NotImplementedError("Not implemented for non-finite and non-simply laced types")
        
        self.lmbd, self.mu = lmbd, mu
        v = tuple([int((self.lmbd-self.mu).to_vector().dot_product(fw.to_vector())) for fw in ambient_space.fundamental_weights()])
        w = tuple([int(self.lmbd.to_vector().dot_product(root.to_vector())) for root in ambient_space.simple_roots()])
        Q1 = self._dynkin_diagram_orientation()
        super().__init__(base_ring, v, w, Q1, spectral_vars, asymptotic, hbar_multiple, var_prefix, diff_prefix)


    def _root_generator_(self, root, degree, verbosity, positive):
        r"""
        Auxiliary function: return a generator E_{\beta}^{(r)} (resp. F_{\beta}^{(r)}) associated to (positive and negative) non-simple root generators.

        .. NOTE:: we use a version of the definition from [Remark 3.4, FKPR2018]. Namely, let \beta be a root and 
        \beta = \alpha_{i_1} + ... + \alpha_{i_l} be a decomposition into simple roots such that the element
        [e_{i_l},[e_{i_{l-1}},[...[e_{i_2},e_{i_1}]]]] is a non-zero element of \g_{\beta}; here \g is the corresponding Lie algebra.
        Then E_{\beta}^{(r)} is defined as as 
        
        .. MATH::
            [E_{i_l}^{(1)}, [eE{i_{l-1}}^{(1)},[...[E_{i_2}^{(1)}, E_{i_1}^{(r)}] ... ]]]

        Negative generators F_{\beta}^{(r)} are defined as 

        .. MATH::

            [[ ... [[F_{i_1}^{(r)}, F_{i_2}^{(1)}], F_{i_3}^{(1)}], ..., F_{i_l}^{(1)}].

        To find such a decomposition, we order the simple roots from *highest* to *lowest* index (according to numeration provided by SageMath 'RootSystem')
        and look for a shortest path in the Hasse diagram of the root system between simple roots (ordered as mentioned above) and this root. 
        We use the SageMath implementation of the Hasse diagram, in particular, its 'shortest_path' function. The result is deterministic.

        To see the explicit commutator realization, one can the parameter 'verbosity' to 'True'. 

        INPUT::
            - ``root`` -- a positive root `\beta` in the notations above
            - ``degree`` -- `r` in the notations above
            - ``verbosity`` -- if `True`, prints the explicit commutator form of the element, otherwise does nothing
            - ``positive`` -- if `True`, return E_{\beta}^{(r)}, otherwise return `F_{\beta}^{(r)}`

        EXAMPLES::

            sage: R = RootSystem("D4"); L = R.coambient_space(); W = L.weyl_group()
            sage: lmbd = L.fundamental_weight(4); mu = W.w0.action(lmbd)
            sage: lmbd
            (1/2, 1/2, 1/2, 1/2)
            sage: mu
            (-1/2, -1/2, -1/2, -1/2)
            sage: G3 = GKLO(QQ, R, lmbd, mu)
            sage: alpha = Lcheck.simple_roots(); alpha
            Finite family {1: (1, -1, 0, 0), 2: (0, 1, -1, 0), 3: (0, 0, 1, -1), 4: (0, 0, 1, 1)}
            sage: beta = alpha[4] + alpha[3] + alpha[2]; beta
            (0, 1, 1, 0)
            sage: type(beta) # Observe that the type is *not* `tuple`
            <class 'sage.combinat.root_system.type_D.AmbientSpace_with_category.element_class'>
            sage: d = G._root_generator_(beta, 1, verbosity=True,positive=True)
            Explicit form: [E_3^(1),[E_2^(1),E_1^(1)]]
            sage: d1 = G._root_generator_((0,1,1,0), 1, verbosity=False, positive=True) # Observe that the input for ``root`` is of type `tuple` with `int` values, as opposed to the presentation of ``beta``
            sage: d1 == d # However, it is absolutely equivalent to ``beta`` as an input
            True
            sage: x = G._root_generator_(beta, 1, verbosity=True,positive=False)
            Explicit form: [[F_1^(1),F_2^(1)],F_3^(1)]
            sage: comm(d,x) # Indeed, it follows from ..CITATION.. that the non-simple root generators associated to \beta should generate a Weyl algebra
            1
        """
        def _simple_root_to_index_(root):
            index_to_root_dict = ambient_space.simple_roots()
            root_to_index_dict = {}
            for key,value in index_to_root_dict.items():
                root_to_index_dict[value] = key-1
            return root_to_index_dict[root]
        
        ambient_space = self.root_system.ambient_space()
        root_poset = ambient_space.root_poset()
        root = root_poset(ambient_space(root))
        simple_roots = [root_poset(a) for a in ambient_space.simple_roots().values()]
        graph = root_poset.hasse_diagram()
        for alpha in simple_roots:
            path = graph.shortest_path(alpha,root)
            if path:
                inp = path[0].element
                simple_root_index = _simple_root_to_index_(inp)
                if positive:
                    string_rep = "E_{}^({})".format(simple_root_index, degree)
                    element = self.E(simple_root_index,degree)
                else:
                    string_rep = "F_{}^({})".format(simple_root_index, degree)
                    element = self.F(simple_root_index,degree)
                for p in path[1:]:
                    output = p.element
                    simple_root_index = _simple_root_to_index_(output - inp)
                    if positive:
                        element = comm(self.E(simple_root_index, 1), element)/self.hbar()
                        string_rep ="[E_{}^({}),".format(simple_root_index,1) + string_rep + "]"
                    else:
                        element = comm(element, self.F(simple_root_index, 1))/self.hbar()
                        string_rep = "[" + string_rep + ",F_{}^({})]".format(simple_root_index, 1)
                    inp = output
                if verbosity:
                    print("Explicit form: {}".format(string_rep))
                return element
            
    def positive_root_generator(self, root, degree, verbosity=False):
        r"""
        Return the positive root generator E_{\beta}^{(r)} associated to ``root``.
        Based on `self._root_generator_(root, degree, verbosity, positive=True)`, see the corresponding description.

        INPUT::
            - ``root`` -- the positive root `\beta` convertible to an element of `self.root_system.ambient_space()` (see examples below for possible inputs)
            - ``degree`` -- `r` in the notations above
            - ``verbosity`` -- (default : `False`) if `True`, print an explicit commutator realization of the corresponding element.

        OUTPUT::
            the positive root generator E_{\beta}^{(r)} for `\beta` = ``root`` and `r` = ``degree``. 

            sage: R = RootSystem("D4"); L = R.coambient_space(); W = L.weyl_group()
            sage: lmbd = L.fundamental_weight(4); mu = W.w0.action(lmbd)
            sage: lmbd
            (1/2, 1/2, 1/2, 1/2)
            sage: mu
            (-1/2, -1/2, -1/2, -1/2)
            sage: G3 = GKLO(QQ, R, lmbd, mu)
            sage: alpha = Lcheck.simple_roots(); alpha
            Finite family {1: (1, -1, 0, 0), 2: (0, 1, -1, 0), 3: (0, 0, 1, -1), 4: (0, 0, 1, 1)}
            sage: beta = alpha[4] + alpha[3] + alpha[2]
            sage: d = G.positive_root_generator(beta, 1, verbosity=True)
            Explicit form: [E_3^(1),[E_2^(1),E_1^(1)]]
            sage: x = G.negative_root_generator(beta, 1, verbosity=True)
            Explicit form: [[F_1^(1),F_2^(1)],F_3^(1)]
            sage: comm(d,x)
            1
        """
        return self._root_generator_(root, degree, verbosity=verbosity, positive=True)

    def negative_root_generator(self, root, degree, verbosity=False):
        r"""
        Return the negative root generator E_{\beta}^{(r)} associated to ``root``.
        Based on `self._root_generator_(root, degree, verbosity, positive=False)`, see the corresponding description.

        INPUT::
            - ``root``: the positive root `\beta` convertible to an element of `self.root_system.ambient_space()` (see examples below for possible inputs)
            - ``degree`` : `r` in the notations above

        OUTPUT::
            the negative root generator F_{\beta}^{(r)} for `\beta` = ``root`` and `r` = ``degree``. 

        EXAMPLES::

            sage: R = RootSystem("D4"); L = R.coambient_space(); W = L.weyl_group()
            sage: lmbd = L.fundamental_weight(4); mu = W.w0.action(lmbd)
            sage: lmbd
            (1/2, 1/2, 1/2, 1/2)
            sage: mu
            (-1/2, -1/2, -1/2, -1/2)
            sage: G3 = GKLO(QQ, R, lmbd, mu)
            sage: alpha = Lcheck.simple_roots(); alpha
            Finite family {1: (1, -1, 0, 0), 2: (0, 1, -1, 0), 3: (0, 0, 1, -1), 4: (0, 0, 1, 1)}
            sage: beta = alpha[4] + alpha[3] + alpha[2]
            sage: d = G.positive_root_generator(beta, 1, verbosity=True)
            Explicit form: [E_3^(1),[E_2^(1),E_1^(1)]]
            sage: x = G.negative_root_generator(beta, 1, verbosity=True)
            Explicit form: [[F_1^(1),F_2^(1)],F_3^(1)]
            sage: comm(d,x)
            1
        """
        return self._root_generator_(root, degree, verbosity=verbosity, positive=False)
    
    def a(self):
        r"""
        Return the dimension vector (a_0, ..., a_{rank(\g)-1}) where \lambda-\mu = a_0*\alpha_0 + ... + a_{rank(\g)-1}*\alpha_{rank(\g)-1}.

        sage: R = RootSystem("E6"); L = R.coambient_space(); W = L.weyl_group()
        sage: lmbd = L.fundamental_weight(1); mu = W.w0.action(lmbd); mu
        (0, 0, 0, 0, -1, 1/3, 1/3, -1/3)
        sage: G3 = GKLO(QQ, R, lmbd, mu)
        sage: G3.a()
        (2, 2, 3, 4, 3, 2)
        sage: G.v()
        (2, 2, 3, 4, 3, 2)
        sage: alpha = L.simple_roots()
        sage: lmbd - mu == 2*alpha[1] + 2*alpha[2] + 3*alpha[3] + 4*alpha[4] + 3*alpha[5] + 2*alpha[6]
        True
        """
        return self._v
    
    def shifts(self):
        r"""
        Return ``L`` of type `list` such that ``L[i]`` is equal to the pairing `(\mu,\alpha_i)`. 

        EXAMPLES::

            sage: R = RootSystem("D4"); L = R.coambient_space(); W = L.weyl_group()
            sage: lmbd = L.fundamental_weight(4); mu = W.w0.action(lmbd); mu
            (-1/2, -1/2, -1/2, -1/2)
            sage: G3 = GKLO(QQ, R, lmbd, mu)
            sage: G3.shifts()
            [0, 0, 0, -1]
        """
        ambient_space = self.root_system.ambient_space()
        return [self.mu.to_vector().dot_product(alpha.to_vector()) for alpha in ambient_space.simple_roots()]

    def _dynkin_diagram_orientation(self):
        r"""
        Auxiliary function: return a Dynkin diagram orientation.

        .. ALGORITHM:: we use numeration of simple roots (=vertices of Dynkin diagram) provided by `RootSystem` in Sage.
            Then i -> j iff i < j in this numeration and C_{ij} = -1, where ``C`` is the Cartan matrix.

        OUTPUT::
            a `tuple` of pairs (i[h], o[h]), where ``h`` is an arrow of the Dynkin diagram and i[h], o[h] are respectively 
            incoming and outcoming vertices.

        EXAMPLES::

            sage: R = RootSystem("D4"); L = R.coambient_space(); W = L.weyl_group()
            sage: lmbd = L.fundamental_weight(4); mu = W.w0.action(lmbd); mu
            (-1/2, -1/2, -1/2, -1/2)
            sage: G3 = GKLO(QQ, R, lmbd, mu)
            sage: G3._dynkin_diagram_orientation()
            ((0, 1), (1, 2), (1, 3))

            sage: R = RootSystem("E6"); L = R.coambient_space(); W = L.weyl_group()
            sage: lmbd = L.fundamental_weight(1); mu = W.w0.action(lmbd); mu
            (0, 0, 0, 0, -1, 1/3, 1/3, -1/3)
            sage: G = GKLO(QQ, R, lmbd, mu)
            sage: G._dynkin_diagram_orientation()
            ((0, 2), (1, 3), (2, 3), (3, 4), (4, 5))
            sage: G.root_system.dynkin_diagram() # Observe that indices are shifted by 1
                    O 2
                    |
                    |
            O---O---O---O---O
            1   3   4   5   6   
            E6
        """
        C = self.root_system.cartan_matrix()
        m, n = C.dimensions()
        Q1 = []
        for i in range(m):
            for j in range(i+1, n):
                if C[i,j] == -1:
                    Q1.append((i,j))
        return tuple(Q1)      

def comm(x,y):
    return x*y - y*x
        

    

